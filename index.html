<!DOCTYPE html>
<html>
  <style>
    p {
      font-size: 20px;
      color: #625d5d;
      line-height: 1.5;
    }
  </style>

  <body>
  <!-- --------- JavaScript Scope --------- -->
  <h1 style="text-align: center;">JavaScript Scope</h1>
  <hr>
  <h4>JavaScript has 2 types of scope:</h4>
  <p>
    <b>Global scope:</b> 
    Variables and functions declared outside of any function are in the global scope and are accessible from anywhere in the code.
  </p>
  <p>
    <b>Local scope:</b> 
    Variables and functions declared inside a function are in the local scope and are only accessible within that function.
  </p>

  <h3>Example: </h3>
  <p id="demo1"></p>

  <!-- demo 2 -->
  <p><b>Local scope message</b> is undefined outside the Function</p>
  <p id="demo2"></p>

  <script>
  
    // Global scope
    
    let name = "John";
    myFunction(); // outputs "Hello, John"
  
    function myFunction() {
      // Local scope
      let message = "Hello, " + name;
      document.getElementById("demo1").innerHTML = message;;
    }

    document.getElementById("demo2").innerHTML = typeof message;

  </script>

  <!-- --------- JavaScript Hoisting --------- -->
  <hr style="margin-top: 150px">
  <h1 style="text-align: center">JavaScript Hoisting</h1>
  <hr>
  <p style="text-align: center;">
    Hoisting is a behavior in JavaScript where variables and function declarations are moved to the top of their scope, 
    <br>regardless of where they are defined. This means that they can be used before they are declared, 
    <br>which can lead to unexpected behavior. Variables declared with the "var" keyword are hoisted, 
    <br>while variables declared with "let" and "const" are not hoisted.
  </p>
  <p id="demo3"></p>
  <p id="demo4"></p>
  <p id="demo5"></p>

  <script>  
    document.getElementById("demo3").innerHTML = x; // Output: undefined
    var x = 10;

    hoistedFunc();     
    function hoistedFunc() {
      document.getElementById("demo4").innerHTML = 'I am a hoisted function: ' + x; // Output: I am a hoisted function: 10
    }

    document.getElementById("demo5").innerHTML = y; // Output: ReferenceError: y is not defined
    let y = 20;

  </script>


  <!-- --------- JavaScript Closures --------- -->
  <hr style="margin-top: 150px">
  <h1 style="text-align: center">JavaScript Closures</h1>
  <hr>
  <p style="text-align: center;">
    A closure is a feature of JavaScript that allows inner functions to access their outer scope.<br>
    A closure is a function having access to the parent scope.
  </p>
  <p>Counting with a local variable.</p>

  <button type="button" onclick="myFunction()">Count!</button>

  <p id="demo6">0</p>
  <p id="demo7"></p>
  <p id="demo8"></p>
  <script>
    // Function to increment counter
    function add() {
      let counter = 0;
      counter += 1;
      return counter;
    }
    // Trying to increment the counter
    function myFunction(){
      document.getElementById("demo6").innerHTML =  add();
    }

    // ---- one more example --------
    function outerFunc(out) {
      return function innerFunc(inn) {
        return out * inn;
      };
    }

    const getFunction = outerFunc(5);
    document.getElementById("demo7").innerHTML = 'Example 1: ' + getFunction(2); // output 10

    // ---- one more example --------

    var a = 10;
    
    const closure = foo(); // Closure  
    closure();

    function foo() {
      var b = 5;
      return function bar() {
        var c = 2;
        var output = a + b + c;
        return output;
      }
    }
    document.getElementById("demo8").innerHTML = 'Example 2: ' +  closure(); // output 
    // executes the function bar which was returned when we executed the function foo in the line above. 

  </script>

  <!-- --------- JavaScript Callbacks --------- -->
  <hr style="margin-top: 150px">
  <h1 style="text-align: center">JavaScript Callbacks</h1>
  <hr>
  <p style="text-align: center;">
    A JavaScript callback is a function that is passed as an argument to another function and is executed after some kind of event.
  </p>
  
  <button type="button" id="callback">button</button>
  <p id="demo9"></p>

  <script>  
    var button = document.getElementById("callback");

    function handleClick() {
      var output = "Button was clicked!"
      document.getElementById("demo9").innerHTML = output; // output 
    }

    button.addEventListener("click", handleClick);
    

    // Here, we are selecting a button element from the HTML document and 
    // creating a handleClick function that logs a message to the console when the button is clicked. 
    // The addEventListener method is used to register an event listener on the button that listens for the click event and 
    // calls the handleClick function as a callback when the button is clicked.
    // Every time the button is clicked, the handleClick function is executed and logs the message "Button was clicked!" to the console.
  
    </script>

    <script>
      function greeting(item) {
        console.log("Hello " + item);
      }

      function processUserInput(callback) {
        var name = 'Doe'
        callback(name);
      }

      processUserInput(greeting);

      // Example: 2
      function getData(callback) {
        // simulate a long-running operation
        setTimeout(function() {
          let data = {
            name: 'John Doe',
            age: 35
          };
          callback(data);
        }, 1000);
      }

      getData(function(item) {
        console.log(item);
      });

      // Example: 3
      function printMessage(message, callback) {
        console.log(message);
        callback();
      }

      function printFinished() {
        console.log('Finished printing message.');
      }

      printMessage('Hello, World!', printFinished); // printFinished is a function used as an argument to another function

      // Example: 4
      function processArray(array, callback) {
        for (let i = 0; i < array.length; i++) {
          callback(array[i]);
        }
      }

      let numbers = [1, 2, 3, 4, 5];

      processArray(numbers, function(item) {
        console.log('item: ', item);
      });

      // Example: 5
      function map(array, callback) {
        let result = [];
        for (let i = 0; i < array.length; i++) {
          result.push(callback(array[i]));
        }
        return result;
      }

      let squared = map(numbers, function(number) {
        return number * number;
      });

      console.log('squared: ', squared); // [1, 4, 9, 16, 25]

      //Example: 6
      function filter(array, callback) {
        let result = [];
        for (let i = 0; i < array.length; i++) {
          if (callback(array[i])) {
            result.push(array[i]);
          }
        }
        return result;
      }


      let evenNumbers = filter(numbers, function(number) {
        return number % 2 === 0;
      });

      console.log('evenNumbers: ', evenNumbers); // [2, 4]

    </script>

    <!-- --------- JavaScript Promises --------- -->
    <hr style="margin-top: 150px">
    <h1 style="text-align: center">JavaScript Promises</h1>
    <hr>
    <p style="text-align: center;">
      A Promise in JavaScript is a way to handle the completion or failure of an asynchronous operation. 
      <br>It's an object that represents the outcome of an operation that may not be finished yet. 
      <br>Promises provide a way to register callbacks to be executed when the operation has completed or failed, 
      <br>making it easier to handle the results of asynchronous operations.
    </p>
   
    <p>
      <code>
        let promise = new Promise(function(resolve, reject) {
        // executor (the producing code, "singer")
      });
      </code>
      <br>
      The function passed to new Promise is called the executor. When new Promise is created, the executor runs automatically. 
      <br>It contains the producing code which should eventually produce the result. In terms of the analogy above: the executor is the “singer”.

      <br><br>Its arguments resolve and reject are callbacks provided by JavaScript itself. Our code is only inside the executor.

      <br><br>When the executor obtains the result, be it soon or late, doesn’t matter, it should call one of these callbacks:

      <br>resolve(value) — if the job is finished successfully, with result value.
      <br>reject(error) — if an error has occurred, error is the error object.
      <br>So to summarize: the executor runs automatically and attempts to perform a job. When it is finished with the attempt, 
      <br>it calls resolve if it was successful or reject if there was an error.

      <br><br>The promise object returned by the new Promise constructor has these internal properties:

      <br>state — initially "pending", then changes to either "fulfilled" when resolve is called or "rejected" when reject is called.
      <br>result — initially undefined, then changes to value when resolve(value) is called or error when reject(error) is called.
    </p>
    <p>Promise Output: <span id="demo10"></span></p>
    <script>
    
      let promise = new Promise((resolve, reject) => {
        let success = Math.random() >= 0.5;

        if (success) {
          resolve("The operation was successful.");
        } else {
          reject("The operation failed.");
        }
      });

      promise.then(value => {
          console.log('value: ', value);
      }).catch(error => {
          console.error('error: ', error);
      });

      // example: 2
      const delay = (time) => {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve();
          }, time);
        });
      };

      console.log('Starting...');
      var times = 3000;

      delay(times)
        .then(() => {
          //console.log(times + ' seconds have passed!');
          let output = times + ' seconds have passed!'
          document.getElementById("demo10").innerHTML = output; // output 
      });

      // example: 2
      const task1 = () => {
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log('Task 1 completed!');
          resolve();
        }, 1000);
      });
    };

    const task2 = () => {
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log('Task 2 completed!');
          resolve();
        }, 2000);
      });
    };

    const task3 = () => {
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log('Task 3 completed!');
          resolve();
        }, 500);
      });
    };

    console.log('Starting all tasks...');

    // in sequence
    task1().then(task2)
      .then(task3)
      .then(() => {
      console.log('All tasks completed in sequence!');
    });

    // In this example, three tasks are defined (task1, task2, task3), 
    // each of which returns a Promise that resolves after a specified amount of time has passed. 
    // The then method is used to run each task in sequence, 
    // so that task2 only starts after task1 has completed, 
    // and task3 only starts after task2 has completed. 
    // When all the Promises have resolved, the final then method logs "All tasks completed in sequence!" to the console.
    
    // Promise.all method 
    Promise.all([task1(), task2(), task3()]).then(() => {
        console.log('All tasks completed!');
    });

    // In this example, three tasks are defined (task1, task2, task3), 
    // each of which returns a Promise that resolves after a specified amount of time has passed. 
    // The Promise.all method is used to run all three tasks in parallel. 
    // When all the Promises have resolved, the then method logs "All tasks completed!" to the console.
    
    </script>


 
  </body>
</html>